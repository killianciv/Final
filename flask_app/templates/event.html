{% extends 'shared/layout.html' %}

{% block extrajs %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
{% endblock %}

{% block extracss %}
<style>
.availability-table {
    border-collapse: collapse;
}
.availability-table th,
.availability-table td {
    border: 1px solid #ccc;
    width: 40px;
    height: 24px;
    text-align: center;
}
.available {
    background-color: #90ee90;
}
.maybe {
    background-color: #ffff99;
}
.unavailable {
    background-color: #f08080;
}
.preview {
    background-color: lightblue !important;
}
</style>
{% endblock %}

{% block maincontent %}
    <!-- The entire edge-to-edge main section (applies main.css styling)-->
    <div id="whole_main">
        <h1> Event {{ event_id }} </h1>
        <p>List of invitees:
            {% for invitee in invitees %}
              {{ invitee }}{% if not loop.last %}, {% endif %}
            {% endfor %}
        </p>
        <div id="availability-grid">
            <label for="status-select">Select availability:</label>
            <select id="status-select">
                <option value="available">Available</option>
                <option value="maybe">Maybe</option>
                <option value="unavailable">Unavailable</option>
            </select>
            <!-- JS creates the availability table and puts it here -->

        </div>
    </div>
    <div class="spacer"></div>

<script type="text/javascript" charset="utf-8">
// Turn the HTML variables for this event (taken from the database by routes.py) into JS
const availability = {{ availability | tojson }};
const eventDates = {{ dates | tojson }};
eventDates.sort((a, b) => new Date(a) - new Date(b));
const eventId = {{ event_id }};
const times = Array.from({length: 28}, (_, i) => {
    const hour = Math.floor(i / 2) + 8;
    const minutes = i % 2 === 0 ? "00" : "30";
    return `${String(hour).padStart(2, '0')}:${minutes}`;
});

// Variables to manage single and group time slot clicks
let selectedStatus = "available";
let isMouseDown = false;
let startCell = null;
let hasInteracted = false;

// Ask a specific cell for its availability status ("unavailable", "maybe", "available")
function getStatus(date, time) {
    const found = availability.find(a => a.date === date && a.time === time);
    return found ? found.status : "unavailable";
}

// Create the grid using JS so that I can assign data values and event listeners to cells
function createGrid() {
    const grid = document.getElementById('availability-grid');
    const table = document.createElement('table');
    table.className = "availability-table";

    // Header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<th>Time</th>`;
    eventDates.forEach((date, col) => {
        const th = document.createElement('th');
        th.textContent = date;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Body
    const tbody = document.createElement('tbody');
    times.forEach((time, row) => {
        // One row (tr) per 30-minute timeslot. The row marked 8:00 represents the 8:00 to 8:30 slot
        const tr = document.createElement('tr');
        const timeTd = document.createElement('td');
        timeTd.textContent = time;
        tr.appendChild(timeTd);
        // One column entry (td) per event date
        eventDates.forEach((date, col) => {
            const status = getStatus(date, time);
            const td = document.createElement('td');
            td.className = `slot ${status}`;
            td.dataset.date = date;
            td.dataset.time = time;
            td.dataset.status = status;  // Each cell knows its own availability status. "unavailable" by default
            td.dataset.row = row;
            td.dataset.col = col;
            // Each cell should know what to do when it is clicked on
            td.addEventListener("mousedown", e => {
                isMouseDown = true;
                startCell = td;
                hasInteracted = true;
                applyStatus(td);
                e.preventDefault();
            });
            // The latest-touched handles the rectangular selection (when you click and drag your mouse)
            td.addEventListener("mouseenter", e => {
                if (isMouseDown && startCell) {
                    document.querySelectorAll(".preview").forEach(c => c.classList.remove("preview"));
                    const cells = getCellsInRectangle(startCell, td);
                    cells.forEach(cell => cell.classList.add("preview"));
                }
            });
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    grid.appendChild(table);
}

// Return the list of cells that are (at least partially) inside the rectangle
//  created by the position you clicked and the current position of your mouse
function getCellsInRectangle(start, end) {
    const startRow = parseInt(start.dataset.row);
    const startCol = parseInt(start.dataset.col);
    const endRow = parseInt(end.dataset.row);
    const endCol = parseInt(end.dataset.col);
    const minRow = Math.min(startRow, endRow);
    const maxRow = Math.max(startRow, endRow);
    const minCol = Math.min(startCol, endCol);
    const maxCol = Math.max(startCol, endCol);
    const cells = [];
    for (let r = minRow; r <= maxRow; r++) {
        for (let c = minCol; c <= maxCol; c++) {
            const cell = document.querySelector(`.slot[data-row="${r}"][data-col="${c}"]`);
            if (cell) cells.push(cell);
        }
    }
    return cells;
}

// Change the color of a cell
function applyStatus(cell) {
    const oldStatus = cell.dataset.status;
    if (oldStatus !== selectedStatus) {
        cell.classList.remove(oldStatus);
        cell.classList.add(selectedStatus);
        cell.dataset.status = selectedStatus;
    }
}

// Get a list of availability dictionaries for every square of the database
// Ex: [{"date": "2025-04-20", "time": "09:00:00", "status": "available"}, ...]
function collectAvailability() {
    return Array.from(document.querySelectorAll(".slot")).map(slot => ({
        date: slot.dataset.date,
        time: slot.dataset.time,
        status: slot.dataset.status
    }));
}

// Save the current total availability state of the event calendar as seen on your screen
function submitAvailability(eventId, availabilityData) {
    $.ajax({
        url: "/save_availability",
        type: "POST",
        contentType: "application/json",
        data: JSON.stringify({
            event_id: eventId,
            availability: availabilityData
        }),
        success: () => console.log("Auto-saved availability."),
        error: (xhr, status, error) => console.error("Error saving availability:", error)
    });
}

// Make the background color of the dropdown match the current availability status
function updateDropdownBackground() {
    const statusSelect = document.getElementById("status-select");
    const status = statusSelect.value;
    if (status === "available") {
        statusSelect.style.backgroundColor = "#90ee90"; // Green
    } else if (status === "maybe") {
        statusSelect.style.backgroundColor = "#ffff99"; // Yellow
    } else if (status === "unavailable") {
        statusSelect.style.backgroundColor = "#f08080"; // Red
    }
}

// As soon as the mouse is lifted, save everything to the database using AJAX
document.addEventListener("mouseup", () => {
    if (isMouseDown && hasInteracted) {
        const previewCells = document.querySelectorAll(".preview");
        previewCells.forEach(cell => {
            cell.classList.remove("preview");
            applyStatus(cell);
        });
        const availabilityData = collectAvailability();
        submitAvailability(eventId, availabilityData);
        hasInteracted = false;
    }
    isMouseDown = false;
    startCell = null;
});

// Tell the status selector (the dropdown) that it must change its color when its value changes
document.addEventListener("DOMContentLoaded", () => {
    const statusSelector = document.getElementById("status-select");
    selectedStatus = statusSelector.value;
    statusSelector.addEventListener("change", e => {
        selectedStatus = e.target.value;
        updateDropdownBackground(); // Update the dropdown background on status change
    });

    updateDropdownBackground(); // Initialize the background color
    createGrid();
});
</script>

{% endblock %}
